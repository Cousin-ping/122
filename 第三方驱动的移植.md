# 第三方驱动的移植
***内核没有的驱动，就需要移植第三方的驱动***
## 黑盒移植
    不关心他底层如何实现的
### 编译驱动进内核
#### a 选择驱动存放目录（或者任意目录）
    一般放到内核driver目录下对应的设备类型（字符设备或者其他设备）的文件夹下

#### b 改Makefile
    不改的话，第三方的驱动C文件不会在内核中编译
#### c 改 Kconfig(界面可配置)
    一般情况下在内核里面makefile旁边都有个Kconfig,Makefile负责具体的编译管理，
    Kconfig负责在界面里显示相关的选项（Kconfig自己有一套语法，感兴趣再学）
    
    大体思路是kconfig里面添加一个新的设备描述（可以仿照其他设备是怎么写的）
    然后你这个kconfig要和makefile关联起来，kconfig本身只是起到一个图形化显示
    的作用，真正的编译还是得靠makefile，如果你的makefile里相关的设备驱动c文件
    编译指令已经写死，那你是不能通过menuconfig来控制是否编译这个驱动
##### Kconfig与menuconfig的关系
    menuconfig执行的时候会自动读取内核源码下的Kconfig，然后生成界面。一个低级菜单对应一个Kconfig
##### Kconfig与menuconfig关联
    顶层目录下的makefile里的编译选项是和kconfig里的一一对应的。也就是说要想
    关联在一起，你的第三方设备的名字在kconfig和makefile里指定的引用变量的名字
    要一样

    比如你在kconfig里写了一个
    config LED
    那么你顶层makefile里要这么写才能关联
    obj-$(CONFIG_LED) += led.o//括号里面一定要大写，这是他规定的语法led.o
    这个文件名要和驱动c文件一样（我这里是led.c)
### 编译驱动为独立的模块
    编译为模块或者编译进内核都是为了方便管理各种驱动而存在的
    a 配置为模块方式
    b make moudles 编译为模块
    c 创建设备节点
    d 运行测试驱动的应用程序
**这部分会在驱动部分讲解，，在其不做赘述**
## 白盒移植
**此处会在驱动编写部分记录**
***移植的时候，平台设备驱动会大大减少我们的工作量***
