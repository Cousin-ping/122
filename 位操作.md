# 位操作
## 位与
    位与&（两个二进制数每一位相与）
    逻辑于&& 是两个操作数作为整体相与
>位与操作的特点是：只有1和1位与的结果为1，其余全是0
## 取反
    注意：C语言中按位取反是~，而逻辑取反是!
    按位取反是将二进制操作数的每一位取反，逻辑取反是真假颠倒
    在C语言中只有0表示假,非零数都是真
```C
#include <stdio.h>
int main(void)
{
    int a=45;
    int b,c;
    b=~a;
    c=!a;
    printf("b= %d\n",b);
    printf("c= %d\n",c);

    return 0;
}

```
上述代码的打印结果会是b=-45,c=0
```C
#include <stdio.h>
int main(void)
{
   unsigned int a=45;
   unsigned int b,c;
    b=~a;
    c=!a;
    printf("b= %u\n",b);
    printf("c= %d\n",c);

    return 0;
}
```
上述代码打印出来的结果b会是一个很大的数字，c还是0
## 清零和置一公式（重点）
- A是被修改数
- B是修改的位数
- C是从第几位开始修改
>可以记为  A从第C位开始，修改B位

__清零公式__
```c
A&=~(B<<C);
```
>将A从第C位开始的B位数，清零

__置一公式__
```c
A|=(B<<C);
```
> 将A从第C位开始的B位数，置一

**如果修改的位数超过两位，或者不是简单的置为1，而是置为随机而定的数，
就可以先清零，后置1**

# 位操作的奇技淫巧
**受限于芯片设计的问题，在嵌入式芯片中，大部分的单片机 SOC FPGA等芯片在进行位运算时速度往往能获得较高的提升**
## 位操作实现乘除法
数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2
## 位操作交换两数
```c
void swap(int &a, int &b) 
{
  a ^= b;
  b ^= a;
  a ^= b;
}
```
*分析*：
- 第一步：a ^= b ---> a = (a^b);
- 第二步：b ^= a ---> b = b^(a^b) ---> b = (b^b)^a = a
- 第三步：a ^= b ---> a = (a^b)^a = (a^a)^b = b
## 位操作判断奇偶数
```c
if(0 == (a & 1)) {
 //偶数
}
```
*分析*：只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。
## 位操作交换符号
负数变正数，正数变负数
```c
int reversal(int a) 
{
  return ~a + 1;
}
```
*分析*：整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数
## 位操作求绝对值
*分析*：整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作
```c
int abs(int a) 
{
  int i = a >> 31;
  return i == 0 ? a : (~a + 1);
}
```
上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)
```c
int abs2(int a)
{
  int i = a >> 31;
  return ((a^i) - i);
}
```
## 位操作进行高低位交换
给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：
```c
34520的二进制表示：
10000110 11011000

将其高8位与低8位进行交换，得到一个新的二进制数：
11011000 10000110
其十进制为55430
```
从上面移位操作我们可以知道，只要将无符号数 a>>8 即可得到其高 8 位移到低 8 位，高位补 0；将 a<<8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a>>8 和 a<<8 进行或操作既可求得交换后的结果。
```c
unsigned short a = 34520;
a = (a >> 8) | (a << 8);
```
## 位操作进行二进制逆序
```c
unsigned short a = 34520;

a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1);
a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2);
a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4);
a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8);
```
## 位操作统计二进制中1的个数
```c
count = 0  
while(a)
{  
  a = a & (a - 1);  
  count++;  
}  
```
## 我的疑惑
这些大神们是怎么想到这些晦涩难懂的用法呢？
该如何自己活学活用位操作来提高代码运行的速度呢？
